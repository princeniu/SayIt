# Whisper (Pro) Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add offline Whisper (whisper.cpp) transcription with model download, selection, and fallback prompts.

**Architecture:** Introduce ModelManager + ModelDownloader + WhisperEngine (whisper.cpp wrapper). AppController coordinates download prompts and engine switching; Popover shows progress below primary button.

**Tech Stack:** Swift/SwiftUI, URLSession, FileManager, whisper.cpp (C/C++), AppKit.

---

### Task 1: Add model metadata + storage layer

**Files:**
- Create: `SayIt/Core/WhisperModel.swift`
- Create: `SayIt/Core/ModelManager.swift`
- Test: `SayItTests/ModelManagerTests.swift`

**Step 1: Write the failing test**

```swift
import Testing
@testable import SayIt

struct ModelManagerTests {
    @Test func modelReady_falseWhenMissingFile() throws {
        let temp = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        let manager = ModelManager(rootURL: temp)
        #expect(manager.isModelReady(.small) == false)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/ModelManagerTests test`
Expected: FAIL (ModelManager not found)

**Step 3: Write minimal implementation**

```swift
// SayIt/Core/WhisperModel.swift
import Foundation

enum WhisperModelType: String, CaseIterable, Codable {
    case tiny, base, small
}

struct WhisperModelSpec: Codable, Equatable {
    let type: WhisperModelType
    let fileName: String
    let expectedSize: Int64
    let sha256: String
    let version: String
}
```

```swift
// SayIt/Core/ModelManager.swift
import Foundation

final class ModelManager {
    private let rootURL: URL
    private let modelsDirName = "Models"

    init(rootURL: URL = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!) {
        self.rootURL = rootURL
    }

    func modelsDirectory() -> URL {
        rootURL.appendingPathComponent("SayIt").appendingPathComponent(modelsDirName)
    }

    func localURL(for type: WhisperModelType) -> URL {
        modelsDirectory().appendingPathComponent("\(type.rawValue).bin")
    }

    func isModelReady(_ type: WhisperModelType) -> Bool {
        FileManager.default.fileExists(atPath: localURL(for: type).path)
    }
}
```

**Step 4: Run test to verify it passes**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/ModelManagerTests test`
Expected: PASS

**Step 5: Commit**

```bash
git add SayIt/Core/WhisperModel.swift SayIt/Core/ModelManager.swift SayItTests/ModelManagerTests.swift
git commit -m "feat: add whisper model metadata manager"
```

---

### Task 2: Implement downloader with progress + cancel

**Files:**
- Create: `SayIt/Core/ModelDownloader.swift`
- Test: `SayItTests/ModelDownloaderTests.swift`

**Step 1: Write the failing test**

```swift
import Testing
@testable import SayIt

struct ModelDownloaderTests {
    @Test func cancel_setsStatusCanceled() async throws {
        let downloader = ModelDownloader()
        downloader.cancel()
        #expect(downloader.status == .canceled)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/ModelDownloaderTests test`
Expected: FAIL (ModelDownloader not found)

**Step 3: Write minimal implementation**

```swift
// SayIt/Core/ModelDownloader.swift
import Foundation

final class ModelDownloader: NSObject, URLSessionDownloadDelegate {
    enum Status: Equatable {
        case idle
        case downloading(Double)
        case completed(URL)
        case failed(String)
        case canceled
    }

    private(set) var status: Status = .idle
    private var task: URLSessionDownloadTask?

    func start(url: URL) {
        let session = URLSession(configuration: .default, delegate: self, delegateQueue: .main)
        task = session.downloadTask(with: url)
        status = .downloading(0)
        task?.resume()
    }

    func cancel() {
        task?.cancel()
        status = .canceled
    }

    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
        status = .completed(location)
    }

    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        if let error { status = .failed(error.localizedDescription) }
    }

    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
        guard totalBytesExpectedToWrite > 0 else { return }
        status = .downloading(Double(totalBytesWritten) / Double(totalBytesExpectedToWrite))
    }
}
```

**Step 4: Run test to verify it passes**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/ModelDownloaderTests test`
Expected: PASS

**Step 5: Commit**

```bash
git add SayIt/Core/ModelDownloader.swift SayItTests/ModelDownloaderTests.swift
git commit -m "feat: add model downloader"
```

---

### Task 3: Add Whisper engine interface + stub bridge

**Files:**
- Modify: `SayIt/Transcription/WhisperEngine.swift`
- Test: `SayItTests/WhisperEngineTests.swift`

**Step 1: Write the failing test**

```swift
import Testing
import AVFoundation
@testable import SayIt

struct WhisperEngineTests {
    @Test func transcribe_requiresModelReady() async throws {
        let engine = WhisperEngine(modelProvider: { _ in nil })
        let buffer = AVAudioPCMBuffer(pcmFormat: AVAudioFormat(standardFormatWithSampleRate: 16000, channels: 1)!, frameCapacity: 1)!
        await #expect(throws: Error.self) {
            _ = try await engine.transcribe(buffer: buffer, locale: .current)
        }
    }
}
```

**Step 2: Run test to verify it fails**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/WhisperEngineTests test`
Expected: FAIL

**Step 3: Write minimal implementation**

```swift
// SayIt/Transcription/WhisperEngine.swift
import AVFoundation

final class WhisperEngine: TranscriptionEngine {
    private let modelProvider: (WhisperModelType) -> URL?
    private let modelType: WhisperModelType

    init(modelType: WhisperModelType = .small, modelProvider: @escaping (WhisperModelType) -> URL?) {
        self.modelType = modelType
        self.modelProvider = modelProvider
    }

    func transcribe(buffer: AVAudioPCMBuffer, locale: Locale) async throws -> String {
        guard modelProvider(modelType) != nil else {
            throw NSError(domain: "Whisper", code: 1, userInfo: [NSLocalizedDescriptionKey: "Model not ready"])
        }
        // TODO: whisper.cpp inference
        return ""
    }
}
```

**Step 4: Run test to verify it passes**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/WhisperEngineTests test`
Expected: PASS

**Step 5: Commit**

```bash
git add SayIt/Transcription/WhisperEngine.swift SayItTests/WhisperEngineTests.swift
git commit -m "feat: add whisper engine stub"
```

---

### Task 4: Add Model status to AppState

**Files:**
- Modify: `SayIt/Core/AppState.swift`
- Test: `SayItTests/AppStateTests.swift`

**Step 1: Write the failing test**

```swift
import Testing
@testable import SayIt

struct AppStateTests {
    @Test func modelStatus_defaultsToIdle() {
        let state = AppState()
        #expect(state.modelStatus == .idle)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/AppStateTests test`
Expected: FAIL

**Step 3: Write minimal implementation**

```swift
// AppState.swift
enum ModelStatus: Equatable {
    case idle
    case downloading(Double)
    case ready(WhisperModelType)
    case failed(String)
}

struct AppState {
    var modelStatus: ModelStatus = .idle
    // existing fields...
}
```

**Step 4: Run test to verify it passes**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/AppStateTests test`
Expected: PASS

**Step 5: Commit**

```bash
git add SayIt/Core/AppState.swift SayItTests/AppStateTests.swift
git commit -m "feat: add model status to app state"
```

---

### Task 5: Wire download prompt + progress into AppController

**Files:**
- Modify: `SayIt/Core/AppController.swift`
- Test: `SayItTests/AppControllerWhisperTests.swift`

**Step 1: Write the failing test**

```swift
import Testing
@testable import SayIt

struct AppControllerWhisperTests {
    @Test func downloadCancel_setsModelStatusIdle() async throws {
        let controller = AppController(autoRequestPermissions: false)
        controller.state.modelStatus = .downloading(0.1)
        controller.cancelModelDownload()
        #expect(controller.state.modelStatus == .idle)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/AppControllerWhisperTests test`
Expected: FAIL

**Step 3: Write minimal implementation**

Add to `AppController`:
```swift
private let modelManager = ModelManager()
private let modelDownloader = ModelDownloader()

func cancelModelDownload() {
    modelDownloader.cancel()
    state.modelStatus = .idle
}
```

**Step 4: Run test to verify it passes**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/AppControllerWhisperTests test`
Expected: PASS

**Step 5: Commit**

```bash
git add SayIt/Core/AppController.swift SayItTests/AppControllerWhisperTests.swift
git commit -m "feat: wire whisper download state"
```

---

### Task 6: Popover UI for download progress + retry

**Files:**
- Modify: `SayIt/Menubar/PopoverView.swift`
- Test: `SayItTests/PopoverViewModelTests.swift`

**Step 1: Write the failing test**

```swift
import Testing
@testable import SayIt

struct PopoverViewModelTests {
    @Test func showsProgress_whenDownloading() {
        let state = AppState()
        var modified = state
        modified.modelStatus = .downloading(0.5)
        #expect(modified.modelStatus == .downloading(0.5))
    }
}
```

**Step 2: Run test to verify it fails**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/PopoverViewModelTests test`
Expected: FAIL

**Step 3: Write minimal implementation**

Add UI section below primary button:
```swift
if case let .downloading(progress) = controller.state.modelStatus {
    ProgressView(value: progress)
        .frame(maxWidth: .infinity)
}
if case let .failed(message) = controller.state.modelStatus {
    Text(message).foregroundColor(.red)
    Button("Retry") { controller.startModelDownload() }
}
```

**Step 4: Run test to verify it passes**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/PopoverViewModelTests test`
Expected: PASS

**Step 5: Commit**

```bash
git add SayIt/Menubar/PopoverView.swift SayItTests/PopoverViewModelTests.swift
git commit -m "feat: show whisper download progress"
```

---

### Task 7: Model selection UI in Settings

**Files:**
- Modify: `SayIt/Settings/SettingsView.swift`
- Test: `SayItTests/SettingsViewModelTests.swift`

**Step 1: Write the failing test**

```swift
import Testing
@testable import SayIt

struct SettingsViewModelTests_WhisperModel {
    @Test func defaultModel_isSmall() {
        let viewModel = SettingsViewModel()
        #expect(viewModel.preferredModel == .small)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/SettingsViewModelTests test`
Expected: FAIL

**Step 3: Write minimal implementation**

Add to `SettingsViewModel`:
```swift
@Published private(set) var preferredModel: WhisperModelType = .small
```

Add Picker to Settings:
```swift
Picker("Whisper Model", selection: $viewModel.preferredModel) {
    Text("Tiny").tag(WhisperModelType.tiny)
    Text("Base").tag(WhisperModelType.base)
    Text("Small").tag(WhisperModelType.small)
}
```

**Step 4: Run test to verify it passes**

Run: `xcodebuild -project SayIt/SayIt.xcodeproj -scheme SayIt -destination 'platform=macOS' -only-testing:SayItTests/SettingsViewModelTests test`
Expected: PASS

**Step 5: Commit**

```bash
git add SayIt/Settings/SettingsView.swift SayIt/Settings/SettingsViewModel.swift SayItTests/SettingsViewModelTests.swift
git commit -m "feat: add whisper model selection"
```

---

### Task 8: Integrate whisper.cpp

**Files:**
- Modify: `SayIt/Transcription/WhisperEngine.swift`
- Add vendor or package integration (TBD)

**Step 1: Add dependency**
- Add whisper.cpp as submodule or SwiftPM dependency.

**Step 2: Write failing integration test**
- Expect transcription to return non-empty for a known short WAV test.

**Step 3: Implement wrapper**
- Use whisper.cpp C API to load model and run inference on the file.

**Step 4: Run tests**
- Confirm real transcription works on short audio.

**Step 5: Commit**

```bash
git add SayIt/Transcription/WhisperEngine.swift <vendor paths>
git commit -m "feat: integrate whisper.cpp"
```

---

### Task 9: Add Whisper manual tests to verification doc

**Files:**
- Modify: `docs/verification-manual.md`

**Step 1: Add Whisper checklist**
- Include download, retry, switch, fallback, model selection.

**Step 2: Commit**

```bash
git add docs/verification-manual.md
git commit -m "docs: add whisper manual verification"
```

---

**Notes / Assumptions**
- Whisper.cpp integration method (submodule vs SwiftPM) will be selected during Task 8.
- Model URLs and hashes will be finalized before download code is wired.

---

Plan complete and saved to `docs/plans/2026-02-04-whisper.md`. Two execution options:

1. **Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration

2. **Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints

Which approach?
